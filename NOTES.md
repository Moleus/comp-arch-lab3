- `asm | acc | neum | hw | tick | struct | trap | port | cstr | prob5 | spi`

набор инструкций как в БЭВМ.
instruction
   : addr operand
   | nonaddr
   | branch label
   | io dev
   ;


TODO: разные адресации - нужны ли они? Или реализуем только абсолютную адресацию
- программа всегда начинается с 0 адреса.

port-mapped - нужны инструкции in/out. Они читают из устройства с номером X в аккумулятор.


tick -- процессор необходимо моделировать с точностью до такта, процесс моделирования может быть приостановлен на любом такте.

struct -- в виде высокоуровневой структуры данных. Считается, что одна инструкция укладывается в одно машинное слово, за исключением CISC архитектур. JSON как в примере

trap - https://gitlab.se.ifmo.ru/computer-systems/csa-rolling/-/blob/master/lab3-task.md#trap
- прерывания внутри процессора (реализация скрыта, можно сделать как хочешь )

cstr -- Null-terminated (C string)

# Step by Step

## Memory organization
- модель памяти процессора:
    - Какие виды памяти и регистров доступны программисту?
        Registers: `acc`
    - Где хранятся инструкции, процедуры и прерывания?
        In single memory array
    - Где хранятся статические и динамические данные?
        In single memory array
- размеры машинного слова: 32bit
- варианты адресации: `direct`
- механику отображения программы и данных на процессор: ????

А также данный раздел должен включать в себя описание того, как происходит работа с 1) литералами, 2) константами, 3) переменными, 4) инструкциями, 5) процедурами, 6) прерываниями во время компиляции и исполнения. К примеру:

## Система команд

### Особенности процессора:
- машинное слово 16? бит, ?
- память представляет собой последовательность 16битных ячеек, в которых могут располагаться как данные так и инструкции.
- может быть записана: только из аккумулятора.
- может быть прочитана: только в аккумулятор
- ввод-вывод - порты ввода/вывода, ???
- прерывания ???
- счетчик комманд (IP) - инкрементируется после каждой инструкции или перезаписывается инструкцией перехода.

### Набор инструкций
addr: AND | OR | ADD | ADC | SUB | CMP | LOOP | LD | SWAM | JUMP | CALL | ST;
nonaddr: NOP | HLT | CLA | NOT | CLC | CMC | ROL | ROR | ASL | ASR | SXTB | SWAB |
INC | DEC | NEG | POP | POPF | RET | IRET | PUSH | PUSHF | SWAP | EI | DI;

### Кодирование инструкций
```json
[
    {
        "opcode": "AND",  // код операции
        "arg": 5,   // аргумент, может отсутствовать
        "term???": [  // информация о месте в исходном коде
            1,
            5,
            "]"
        ]
    }
]
```

## Транслятор

<!-- TODO: описание CLI -->
Консольное приложение cli
input: `translator.bin <input_file> <target_file> [flags]`

### Принципы работы транслятора (этапы, правила и т.п)
Этапы трансляции (функция Х):

1. Трансформация ассемблерного текста в последовательность термов
2. Генерация машинного кода???

*TODO: подробнее расписать как мы парсим ассемлерный код с метками и инструкциями*

## Модель процессора

Описание CLI приложения

Взять диаграмку из BCOMP-ng

### DataPath

### ControlUnit

